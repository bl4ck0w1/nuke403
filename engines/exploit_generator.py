# engines/exploit_generator.py
from __future__ import annotations

import logging
import json
from typing import Dict, List, Optional, Tuple, Any
from copy import deepcopy
from urllib.parse import urljoin

logger = logging.getLogger(__name__)


class ExploitGenerator:
    def __init__(self, payload_gan: Optional[Any] = None):
        self.payload_gan = payload_gan
        self.exploit_templates = self._load_exploit_templates()
        self.technique_family_map = {
            "trim_inconsistency": "path_traversal",
            "path_smuggling": "path_traversal",
            "path_smuggling_redirect": "path_traversal",
            "matrix_parameters": "path_traversal",
            "matrix_parameters_redirect": "path_traversal",
            "matrix_parameters_ssrf": "path_traversal",
            "dotless_ip": "path_traversal",
            "line_folding": "header_injection",
            "cache_poisoning": "header_injection",
            "host_inheritance": "header_injection",
            "chunked_encoding": "protocol_attack",
            "http09_backchannel": "protocol_attack",
            "http09_bypass": "protocol_attack",
            "http09_method_test": "protocol_attack",
            "method_override": "method_override",
        }

    def _load_exploit_templates(self) -> Dict[str, Dict]:
        try:
            with open("payloads/exploit_templates.json", "r", encoding="utf-8") as f:
                data = json.load(f)
                if not isinstance(data, dict):
                    raise ValueError("exploit_templates.json must contain an object at top level")
                return data
        except Exception as e:
            logger.warning(f"Exploit templates not found or invalid, using defaults: {e}")
            return self._get_default_templates()

    def _get_default_templates(self) -> Dict[str, Dict]:
        return {
            "path_traversal": {
                "description": "Path / normalization exploit",
                "template": "{url}", 
                "headers": {},
                "method": "GET",
            },
            "header_injection": {
                "description": "Header-manipulation exploit",
                "template": "{url}",
                "headers": {"{header_name}": "{header_value}"},
                "method": "GET",
            },
            "method_override": {
                "description": "HTTP method override exploit",
                "template": "{url}",
                "method": "{method}",
                "headers": {},
            },
            "protocol_attack": {
                "description": "Protocol-level attack (manual/raw socket often required)",
                "template": "{url}",
                "headers": {},
                "method": "GET",
            },
        }

    def generate_exploit(self,bypass_result: Dict, persona: Optional[Dict[str, str]] = None, gan_variants: int = 0, ) -> Dict:
        technique = bypass_result.get("technique", "unknown")
        family = self.technique_family_map.get(technique, None)

        if family and family in self.exploit_templates:
            template = deepcopy(self.exploit_templates[family])
            exploit = self._fill_template(template, bypass_result)
        else:
            exploit = self._generate_custom_exploit(bypass_result)

        meta = {
            "technique": technique,
            "family": family or "custom",
            "persona_id": (persona or {}).get("persona_id") or bypass_result.get("persona_id"),
            "ja3": (persona or {}).get("ja3") or bypass_result.get("ja3"),
            "alpn": (persona or {}).get("alpn") or bypass_result.get("alpn"),
            "hops": bypass_result.get("hops"),
            "cache_hit": bypass_result.get("cache_hit"),
            "cookie_fingerprint": bypass_result.get("cookie_fingerprint"),
            "proofs": bypass_result.get("proofs") or [],
        }
        exploit["meta"] = {k: v for k, v in meta.items() if v is not None}
        
        if gan_variants > 0 and self.payload_gan is not None:
            persona_bias = {
                "waf": (persona or {}).get("waf") or bypass_result.get("waf"),
                "backend": (persona or {}).get("backend") or bypass_result.get("backend"),
            }
            try:
                variants = self.payload_gan.generate(n=gan_variants, persona=persona_bias)
            except Exception as e:
                logger.debug(f"PayloadGAN generation failed: {e}")
                variants = []
            if variants:
                exploit.setdefault("payload_variants", variants)

        return exploit

    def generate_exploit_chain(self, bypass_results: List[Dict], persona: Optional[Dict[str, str]] = None, gan_variants_each: int = 0, ) -> List[Dict]:
        chain: List[Dict] = []
        seen: set = set()

        for br in bypass_results:
            ex = self.generate_exploit(br, persona=persona, gan_variants=gan_variants_each)
            key = (
                ex.get("method", "GET").upper(),
                ex.get("url", ex.get("template", "")),
                tuple(sorted((ex.get("headers") or {}).items())),
            )
            if key not in seen:
                chain.append(ex)
                seen.add(key)

        return chain

    def generate_poc_script(self, exploit: Dict, language: str = "python") -> str:
        lang = (language or "").lower()
        if lang == "python":
            return self._generate_python_poc(exploit)
        if lang == "curl":
            return self._generate_curl_poc(exploit)
        if lang in ("javascript", "js"):
            return self._generate_javascript_poc(exploit)
        return self._generate_generic_poc(exploit)

    def _fill_template(self, template: Dict, bypass_result: Dict) -> Dict:
        exploit = deepcopy(template)
        url_from_result = bypass_result.get("url") or ""
        payload = bypass_result.get("payload") or ""
        base_url = bypass_result.get("base_url") or url_from_result

        if url_from_result:
            final_url = url_from_result
        else:
            final_url = (base_url.rstrip("/") + payload) if payload else base_url

        if "template" in exploit:
            try:
                exploit_url = exploit["template"].format(url=final_url, payload=payload)
            except Exception:
                exploit_url = final_url
            exploit["url"] = exploit_url
            exploit["template"] = exploit.get("template")

        filled_headers: Dict[str, str] = {}
        src_headers = exploit.get("headers") or {}
        for k, v in list(src_headers.items()):
            new_k = k.format(header_name=bypass_result.get("header", k))
            new_v = v.format(header_value=bypass_result.get("value", bypass_result.get("header_value", v)))
            filled_headers[new_k] = new_v
        for k, v in (bypass_result.get("headers") or {}).items():
            filled_headers[k] = v
        exploit["headers"] = filled_headers or {}

        method = exploit.get("method", "GET")
        try:
            exploit["method"] = method.format(method=bypass_result.get("method", method)).upper()
        except Exception:
            exploit["method"] = (bypass_result.get("method") or method or "GET").upper()

        if payload and "payload" not in exploit:
            exploit["payload"] = payload

        return exploit

    def _generate_custom_exploit(self, bypass_result: Dict) -> Dict:
        url = bypass_result.get("url") or bypass_result.get("base_url") or ""
        method = (bypass_result.get("method") or "GET").upper()
        headers = bypass_result.get("headers") or {}
        payload = bypass_result.get("payload") or ""

        return {
            "description": f"Custom exploit for {bypass_result.get('technique', 'unknown')}",
            "url": url,
            "headers": headers,
            "method": method,
            "payload": payload,
            "confidence": bypass_result.get("confidence", 0.5),
        }

    def _generate_python_poc(self, exploit: Dict) -> str:
        url = exploit.get("url", "")
        headers = exploit.get("headers") or {}
        method = (exploit.get("method") or "GET").upper()
        body = exploit.get("body") or ""
        script = (
            "import requests\n\n"
            f'url = "{url}"\n'
            f"headers = {json.dumps(headers, indent=2)}\n"
            f'method = "{method}"\n'
            "data = " + (json.dumps(body) if isinstance(body, (dict, list)) else (f'"""{body}"""' if body else "None")) + "\n\n"
            "resp = requests.request(method, url, headers=headers, data=data, timeout=20, verify=False)\n"
            "print('Status:', resp.status_code)\n"
            "print('Length:', len(resp.text))\n"
            "print('Preview:', resp.text[:400])\n"
        )
        return script

    def _generate_curl_poc(self, exploit: Dict) -> str:
        url = exploit.get("url", "")
        headers = exploit.get("headers") or {}
        method = (exploit.get("method") or "GET").upper()
        body = exploit.get("body") or ""

        parts = [f"curl -i -k -X {method} '{url}'"]
        for k, v in headers.items():
            parts.append(f"-H '{k}: {v}'")
        if body:
            parts.append(f"--data-binary $'{body.replace(\"'\", \"'\\''\")}'")
        return " \\\n  ".join(parts)

    def _generate_javascript_poc(self, exploit: Dict) -> str:
        url = exploit.get("url", "")
        headers = exploit.get("headers") or {}
        method = (exploit.get("method") or "GET").upper()
        body = exploit.get("body") or None

        js = (
            f"fetch('{url}', {{\n"
            f"  method: '{method}',\n"
            f"  headers: {json.dumps(headers, indent=2)},\n"
            f"  body: {json.dumps(body) if body is not None else 'undefined'}\n"
            "}})\n"
            ".then(r => r.text())\n"
            ".then(t => console.log('Status:', /* no status in fetch text directly */, 'Preview:', t.slice(0,400)))\n"
            ".catch(e => console.error('Error:', e));\n"
        )
        return js

    def _generate_generic_poc(self, exploit: Dict) -> str:
        url = exploit.get("url", "")
        headers = exploit.get("headers") or {}
        method = (exploit.get("method") or "GET").upper()
        payload = exploit.get("payload") or ""
        body = exploit.get("body") or ""

        return (
            "Exploit Details:\n"
            f"- URL: {url}\n"
            f"- Method: {method}\n"
            f"- Headers: {json.dumps(headers, indent=2)}\n"
            f"- Payload: {payload}\n"
            f"- Body: {(body if isinstance(body, str) else json.dumps(body))}\n\n"
            "Instructions:\n"
            f"1. Send a {method} request to {url}\n"
            "2. Include the headers above.\n"
            f"3. If applicable, include the payload/body shown.\n"
        )
